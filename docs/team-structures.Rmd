---
title: "The impact of team structure on problem solving performance"
author:
  - { name: Pierce Edmiston, affiliation_id: 1 }
  - { name: Maxime Derex, affiliation_id: 2 }
  - { name: Gary Lupyan, affiliation_id: 1 }
affiliation:
  - id: 1
    department: Department of Psychology
    university: University of Wisconsin-Madison
  - id: 2
    department: Biosciences Department
    university: University of Exeter
email: pedmiston\@wisc.edu
address: 1202 W. Johnson St., Department of Psychology, University of Wisconsin, Madison, WI 53703.
bibliography: "references.bib"
csl: "templates/plos-one.csl"
output:
  bookdown::pdf_document2:
    template: templates/plos-one.tmpl
    keep_tex: yes
    number_sections: no
---
```{r team-structures-config, include=FALSE}
library(knitr)
library(crotchet)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  results = "hide",

  # PLOS One figure requirements.
  # Width: 789 – 2250 pixels (at 300 dpi). Height maximum: 2625 pixels (at 300 dpi).
  fig.width = 3,
  fig.height = 3,
  dpi = 300
)

# Read all knitr chunks in .R files
chunks_dir <- "R"
read_chunk(file.path(chunks_dir, "team-structures.R"))
```

```{r Setup}
```

# Introduction {-}

```{r Intro}
```

(ref:types-of-time) Team structures controlling for labor time. **Left.** Team structures. Each node is a person. **Middle.** Relationship between labor time and calendar time. Synchronic teams spend labor time more quickly than the other strategies. **Right.** Learning times by strategy, showing that an isolated strategy provides the most time for individual learning.

```{r types-of-time, fig.width=5, fig.height=2, fig.cap="(ref:types-of-time)"}
gridExtra::grid.arrange(
  crotchet::read_graphviz("team-structures", package = "totems"),
  gg_time,
  gg_person,
  nrow = 1,
  widths = c(0.25, 0.375, 0.375)
)
```

# Methods {-}

```{r Methods}
```

## Team structures {-}

Participants were randomly assigned to complete the same problem solving task in
different team structure conditions (Fig. \@ref(fig:team-structures-all)).
Participants in the diachronic condition worked on the problem solving task one
at a time. At the end of a diachronic participant's session, the solutions they
discovered were passed on to be inherited by a single participant assigned
to the next generation of the same team.

Participants assigned to the synchronic team structure worked independently and
in parallel. Their labor was coordinated such that solutions discovered by one
team member were immediately shared with the other members of the team.

Isolated participants completed the problem solving task as individuals, only
benefiting from the solutions they could discover on their own. Isolated participants
completed the experiment in a single 50 minute session or, in a different condition,
came back for four 25 minute sessions.

(ref:team-structures-all) Team structures. Diachronic participants worked one
at a time, each inheriting the solutions discovered by the previous generation,
labeled G1-G4. Isolated participants were recruited for a single 50 minute
session, or returned for four 25 minute sessions, labeled S1-S4. Synchronic
participants were assigned to teams of two or four individuals that all worked
at the same time.

```{r team-structures-all, out.width="80%", fig.cap='(ref:team-structures-all)'}
crotchet::draw_graphviz("team-structures-all", package = "totems")
```

## Problem solving task {-}

Participants played the "Totems" game adapted from @Derex:2015cbb. Their task
was to discover tools that could be used with the ultimate goal of creating "a sacred
totem to appease the gods." To build a totem, participants first needed to
construct an axe out of three independently discovered tools: a refined stick
used as a handle, a sharpened rock for the blade, and a string wound from bark
fibers for binding (Fig. \@ref(fig:landscape-sample)). More advanced tools
produce larger and more intricate totems, resulting in higher performance
scores.

Participants could combine up to four items at a time (with replacement),
meaning the initial six items could form a total of
`r methods$n_unique_combinations_6` combinations. Of all possible combinations,
very few resulted in new items. For example, of all the combinations that could
be formed from the initial items, only three
(`r methods$n_unique_combinations_6_pct`%) yielded new tools.

As tools are accumulated, the combinatorial complexity of the problem
space increases exponentially such that the discovery of more complex tools was
less likely to happen by chance alone. However, combinatorial complexity
would be a more valid measure of difficulty if participants were guessing
entirely at random. In reality participants are far more likely to make some
guesses than others. For example, once discovering an axe, participants quickly
discover that they can use the axe to chop down a tree, regardless of the
other tools they may have. At the same time, participants do not find all tools
equally intuitive, and the difference in combinatorial complexity should not be
ignored. In our results, we report performance based on both measures.

(ref:landscape-sample) A sample of the solution landscape. The top row of 6
items were available to problem solvers at the start of the game. New items
could be produced through the combination of different items (more than one
arrow points to the item) or through the refinement of a single item (a single
arrow points to the item). The axe is required to construct the first totem
pole.

```{r landscape-sample, fig.width=5, fig.cap="(ref:landscape-sample)"}
draw_image("landscape-sample.gv", package = "totems")
```

Once a tool was discovered, the recipe for its creation---a list of the items
that had to be combined in order to create the tool---was recorded in an
innovation record (Fig. \@ref(fig:innovation-record)). Participants could review their
past innovations and click to see its recipe.

The innovation record was also used as the means for sharing solutions among
members of a team and across sessions. For diachronic participants after the
first generation, the innovation record of the previous generation participant
was available to them from the start of the experiment. They could view their
predecessors' innovation record and see how to make each one. Participants
assigned to the synchronic condition could view the innovation records of each
of their teammates throughout the session. Once someone on a team discovered
a tool, the recipe for its creation could be viewed by all members of the team.
Isolated participants returning for multiple sessions started with the
innovation record from their previous session.

Note that the innovation records provided the recipes for creating the tools,
but not the tools themselves. In order use these tools in further combinations,
the tools, including all of the constituent parts, first had to be created.

(ref:innovation-record) Example innovation record.

```{r innovation-record, fig.cap="(ref:innovation-record)", eval=FALSE}
draw_image("innovation-record", "totems")
```

(ref:interface) The Totems gameplay interface. Participants generated guesses
by dragging items into the **Workshop** and selecting the "Try" button. If the
guess created an item, it could be dragged into the **Stock** panel, and used
again in later combinations. Once segments of a totem were made through
cutting, carving, and painting, they could be dragged into the **Totem** panel
for scoring.

```{r interface, fig.cap="(ref:interface)", out.width="100%"}
draw_image("gameplay", "totems")
```

## Participants {-}

Participants were undergraduate students at the University of Wisconsin-Madison
who completed the experiment in exchange for course credit. Students received
credit based on the duration of each completed session. Sessions were either 25
minutes or 50 minutes. Participants assigned to the Isolated, multi-session
condition who completed all four sessions were awarded additional credit as
an incentive to prevent dropout.

(ref:condition-counts) Total participant and team recruitment.

```{r counts-table, results="asis"}
kable(ConditionCounts, caption = "(ref:condition-counts)")
```

# Experiment 1: Simple diachronic inheritance {-}

```{r 50min}
```

In Experiment 1, we compared the simplest form of diachronic inheritance---a
two-person diachronic team---to two alternative strategies for allocating the
same 50 minutes of labor: isolated individuals working alone and two-person
synchronic teams (Fig. \@ref(fig:team-structures-50min)).

(ref:team-structures-50min) Team structures compared in Experiment 1.

```{r team-structures-50min, out.width="50%", fig.cap="(ref:team-structures-50min)"}
crotchet::draw_graphviz("team-structures-50min", package = "totems")
```

## Results {-}

### Innovations {-}

The number of innovations discovered using each of the three team strategies is
shown in Fig. \@ref(fig:innovations-50min). Our primary hypothesis concerned
the effectiveness of a diachronic strategy as compared to the alternative
strategies for solving the same problems in the same amount of time, but
without diachronic inheritance. The results show that when controlling for
labor hours, a diachronic strategy is as effective as either alternative
strategy. Diachronic teams discovered more innovations on average than isolated
individuals, but post hoc tests revealed that this difference was not
statistically significant, `r exp1$DG2_v_I50`. Conversely, diachronic teams
discovered fewer innovations on average than two-person synchronic teams, but
again this difference was not statistically significant, `r exp1$S2_v_DG2`.

We did find an overall benefit to teamwork in this task. To test this,
we compared two-person teams (both diachronic and synchronic) to isolated
individuals. Teams performed reliably better on this task than individuals,
`r exp1$teamwork_stats`, without a significant residual difference between the
diachronic and synchronic strategies, `r exp1$teamwork_residual`. Post hoc tests
revealed that this effect of teamwork was driven primarily by synchronic teams
outperforming isolated individuals, `r exp1$S2_v_I50`. This result, showing an
advantage of teamwork over individual labor, suggests that maximizing individual
learning time is not always the most effective way to improve problem solving
performance.

(ref:innovations-50min) Innovations discovered in 50 labor minutes by strategy.
**A.** Rate of innovation by labor hours. Each line is the average number of
innovations discovered by participants in each condition. **B.** Final
innovations by strategy. Each point is a single participant. Bars with errors
show model predictions with ±1 standard error.

```{r innovations-50min, fig.width=5, fig.height=3, fig.cap="(ref:innovations-50min)"}
grid.arrange(
  innovation_rate_50min_plot + ggtitle("A"),
  num_innovations_50min_plot + ggtitle("B"),
  nrow = 1,
  widths = c(0.55, 0.45)
)
```

### Guesses per innovation {-}

In addition to comparing the three strategies in terms of overall performance,
we also performed a more fine-grained analysis of guessing behaviors. First we
compared the three strategies in terms of how many guesses were required to
discover each new innovation. To count the number of guesses that were required
for each innovation, we tallied all guesses made from the moment in which a new
item was eligible for discovery until that item was discovered. A new item was
eligible for discovery once all of the items required to create the new item
had been discovered. We refer to new items that are eligible for discovery
as adjacent items, since they are adjacent to the current inventory in the
overall problem space. The minimum number of adjacent items for any inventory
was one, indicating that there was a single innovation that must be discovered
before new items can be created. The median number of adjacent items was four.
When there was more than one adjacent item, each guess counted toward the total
number of guesses for each of the adjacent items not created by the guess.

We found that diachronic inheritance reduced the average number of guesses
required to discover each item relative to the same items being guessed by
participants in either the isolated or synchronic conditions,
`r exp1$guesses_per_item_inheritance` (Fig.
\@ref(fig:guesses-per-innovation)A). However, we found that this overall benefit
to inheritance in terms of fewer guesses per item did not extend to items that
had not been discovered by the previous generation. Comparing the number of
guesses per item only for items that were newly discovered by the second
generation diachronic problem solvers did not reveal a benefit to inheritance,
`r exp1$guesses_per_new_item_inheritance` (Fig. \@ref(fig:guesses-per-innovation)B).

(ref:guesses-per-innovation) Guesses per innovation by inheritance condition.
Each thin gray line shows the average number of guesses for a particular
innovation. **A.** Guesses per innovation for all tools. **B.** Guesses per
innovation for new tools, not discovered by an ancestor.

```{r guesses-per-innovation, fig.width=5, fig.cap="(ref:guesses-per-innovation)"}
gridExtra::grid.arrange(
  guesses_per_item_plot + ggtitle("A"),
  guesses_per_new_item_plot +
    ggtitle("B") +
    theme(
      axis.title.y = element_blank(),
      axis.text.y = element_blank()
    ),
  nrow = 1,
  widths = c(0.55, 0.45)
)
```

### Guessing strategy {-}

We next analyzed the effectiveness of the guessing strategies employed by
participants in each strategy. The analyses of guesses reported above treat all
incorrect guesses as the same, but in reality some guessing strategies are more
optimal than others. Specifically, in this task an optimal guessing strategy is
to only attempt unique guesses. However, in the Totems game, many people end up
making repeat guesses, thus employing a suboptimal strategy. The nature of these
repeat guesses varies, as there are a total of four types of guesses that can be
made. The different guess types are shown in Table \@ref(tab:guess-types).

(ref:guess-types) Guess types. Each guess can be categorized into one of four
types. Redundant guesses were incorrect guesses made once before. Repeat items
were recreated tools. Unique guesses were incorrect guesses never made. Unique
items were unique guesses that created a new tool.

```{r guess-types, results="asis"}
recode_guess_type() %>%
  select(`Guess type` = GuessTypeLabel,
         `Unique guess` = UniqueGuess,
         `Created item` = CreatedItem,
         `Unique result` = UniqueResult) %>%
  kable(caption = "(ref:guess-types)")
```

We calculated the proportion of guesses made by participants in each condition
falling into the four guess types. Our results are shown in Fig.
\@ref(fig:guess-props).

For our analysis, we were particularly interested in the proportions of
redundant and unique guesses. Looking just at redundant guesses, we found
that inheritance caused participants to guess fewer redundant guesses
than the the other strategies, `r exp1$prop_redundant_inheritance`.
Post hoc comparisons revealed that second generation diachronic
participants had a lower percentage of redundant guesses than first
generation participants, `r exp1$prop_redundant_dg2`, and isolated
individuals, `r exp1$prop_redundant_i50`, but not synchronic participants,
`r exp1$prop_redundant_i50`.

Looking at the proportion of unique guesses, we found no overall effect of
inheritance, `r exp1$prop_unique_inheritance`. Pairwise comparisons revealed
a significant difference between second generation diachronic participants
and isolated individuals, `r exp1$prop_unique_i50`, but not between second and
first generation diachronic players, `r exp1$prop_unique_dg2`, and not between
diachronic and synchronic strategies, `r exp1$prop_unique_s2`.

(ref:guess-props) Guessing strategies by team structure. DG1 and DG2 refer to first
and second generation diachronic participants. I50 refers to isolated participants
given 50 minutes. S2 refers to two-person synchronic teams.

```{r guess-props, fig.width=5, fig.cap="(ref:guess-props)"}
prop_guess_types_50min_plot
```

## Discussion {-}

In Experiment 1, we found that inheriting from a previous generation problem solver
is comparable to alternative strategies for solving the same set of problems. Two
generations of problem solvers working for 25 minutes each results in similar final
performance to an isolated individual given 50 minutes and two problem solvers
working in parallel for 25 minutes each.

We detected the effects of inheriting from a previous generation in the guessing efficiency
and guessing strategies employed by diachronic problem solvers. Inheriting the solutions
from a previous generation improved the efficiency of future generations of problem solvers
by allowing them to recreate those same items with fewer guesses overall. However, this
improvement in efficiency did not extend to future problem solving, as second generation
diachronic problem solvers were not any more efficient in solving problems that had not
been discovered by their ancestor.

Second generation diachronic players did seem to employ a different guessing strategy
as reflected in the distribution of guesses by type. In this game, redundant guesses
are unhelpful in that they will never yield new discoveries, and yet most participants
generate a significant proportion of redundant guesses. This detrimental tendency to guess
redundantly may be lessened by diachronic collaboration, as second generation
diachronic problem solvers generated fewer redundant guesses than their
ancestors and participants in an isolated strategy. However, similar proportions
of redundant guesses were generated by participants in the synchronic strategy.

The results of Experiment 1 support and extend the original findings reported by
@Derex:2015cbb that synchronic collaboration can result in an improvement in
problem solving performance relative to isolated individuals working alone. Here
we demonstrate that this advantage holds even when labor hours are controlled.

Next we report the results of an Experiment designed to compare a diachronic
strategy to one in which the same individual returns for multiple visits.

# Experiment 2: Inheriting from self or other {-}

```{r SelfOther}
```

In Experiment 2, we compare the effectiveness of inheriting from someone else to
the effectiveness of inheriting from yourself (Fig.
\@ref(fig:team-structures-selfother)). In this experiment, participants were
assigned to the diachronic condition or the isolated condition. Participants in
the isolated condition were asked to come back to the experiment for four
separate sessions, each 25 minutes long. At each session after the first, these
participants inherited the recipes for the tools they had created at the end of
the previous session.

(ref:team-structures-selfother) Problem solving strategies compared in Experiment 2.

```{r team-structures-selfother, out.width="70%", fig.cap="(ref:team-structures-selfother)"}
crotchet::draw_graphviz("team-structures-selfother", package = "totems")
```

## Results {-}

```{r innovations-by-generation-selfother, fig.width=5}
innovations_by_generation_plot
```

```{r cost-of-first-innovation, fig.width=5}
first_discovery_by_generation_plot
```

## Discussion {-}

# Experiment 3: Scalability of diachronic and synchronic collaboration {-}

```{r TeamSize}
```

## Results {-}

```{r max-innovations-by-teamsize, fig.width=5}
max_innovations_by_teamsize_plot
```

```{r bots-teamsize, fig.width=5}
bots_team_size_plot
```

## Discussion {-}

# General Discussion {-}
